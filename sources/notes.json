{
  "notes": [
    {
      "title": "Agrega datos al final de una matriz.",
      "action": "Agrega datos al final de una matriz.",
      "code": ".push()",
      "example": "myArray.push(4)"
    },
    {
      "title": "Agrega datos al inicio de una matriz.",
      "action": "Agrega datos al inicio de una matriz.",
      "code": ".unshift",
      "example": "myArray.unshift(4)"
    },
    {
      "title": "Elimina el último elemento de una matriz",
      "action": "Elimina el último elemento de una matriz",
      "code": ".pop()",
      "example": "myArray.pop()"
    },
    {
      "title": "Elimina el primer elemento de una matriz",
      "action": "Elimina el primer elemento de una matriz",
      "code": ".shift",
      "example": "myArray.shift()"
    },
    {
      "title": "Determinar si ese objeto tiene el nombre de propiedad dado.",
      "action": "Determinar si ese objeto tiene el nombre de propiedad dado.",
      "code": ".hasOwnProperty(propname)",
      "example": ".hasOwnProperty()devuelve trueo falsesi la propiedad se encuentra o no."
    },
    {
      "title": "Acceder al valor de una propiedad de un objeto.",
      "action": "Acceder al valor de una propiedad de un objeto.",
      "code": "obj[nameProperty]",
      "example": "data"
    },
    {
      "title": "Acceder a matrices anidadas",
      "action": "Acceder a matrices anidadas",
      "code": "ourPets[0].names[1];",
      "example": "data"
    },
    {
      "title": "Congelar un objeto para evitar su modificación",
      "action": "Congelar un objeto para evitar su modificación",
      "code": "Object.freeze(obj);",
      "example": "data"
    },
    {
      "title": "Crear arrow function",
      "action": "Crear arrow function",
      "code": "const magic = () => new Date();",
      "example": "let magic = () => new Date()"
    },
    {
      "title": "concatena cadenas ",
      "action": "concatena cadenas ",
      "code": "concat(arr2)",
      "example": "const myConcat = (arr1, arr2) => arr1.concat(arr2)"
    },
    {
      "title": "Establecer parámetros predeterminados para sus funciones",
      "action": "Establecer parámetros predeterminados para sus funciones",
      "code": "const greeting = (name ='Anonymous') =>'Hello ' + name;",
      "example": "data"
    },
    {
      "title": "Crear Objeto",
      "action": "Crear Objeto",
      "code": " var obj { clave:valor;}",
      "example": "data"
    },
    {
      "title": "Crear elementos html en javascritpt",
      "action": "Crear elementos html en javascritpt",
      "code": "const myH2 = document.createElement('h2');",
      "example": " const myArticle = document.createElement('article')"
    },
    {
      "title": "Establecer parámetros predeterminados",
      "action": "Establecer parámetros predeterminados para sus funciones",
      "code": "const greeting = (name = 'Anonymous') => 'Hello ' + name;",
      "example": "print(greeting('John'))//Hello John"
    },
    {
      "title": "Parámetro rest",
      "action": "Parámetro rest para los parámetros de función. El parámetro rest elimina la necesidad de verificar la matriz args y nos permite aplicar map(), filter() y reduce() en la matriz de parámetros. Los … puntos es el operador que va acompañado en este ejemplo de la palabra args",
      "code": "function howMany(...args) {  return 'You have passed' + args.length +' arguments.';}",
      "example": "data"
    },
    {
      "title": "El método reduce() ",
      "action": "El método reduce() ejecuta una función reductora sobre cada elemento de un array, devolviendo como resultado un único valor.",
      "code": "Array.prototype.reduce()",
      "example": "const array1 = [1, 2, 3, 4] const reducer = (accumulator, currentValue) => accumulator + currentValue"
    },
    {
      "title": "Operador de propagación",
      "action": "Operador de propagación , que nos permite expandir matrices y otras expresiones en lugares donde se esperan múltiples parámetros o elementos.",
      "code": "var arr = [6, 89, 3, 45]; var maximus = Math.max.apply(null, arr);",
      "example": "Tuvimos que usar Math.max.apply(null, arr) porque Math.max(arr)devuelve NaN. Math.max()espera argumentos separados por comas, pero no una matriz. El operador de propagación hace que esta sintaxis sea mucho mejor de leer y mantener. el operador de propagación solo funciona en el lugar, como en un argumento para una función o en un literal de matriz"
    },
    {
      "title": "asignación de desestructuración",
      "action": "La asignación de desestructuración es una sintaxis especial introducida en ES6, para asignar claramente valores tomados directamente de un objeto.",
      "code": "const {prop1, prop2 } = object;",
      "example": "const HIGH_TEMPERATURES = {  yesterday: 75,  today: 77,  tomorrow: 80 } const {today, tomorrow} = HIGH_TEMPERATURES"
    },
    {
      "title": "Cambiar nombres con la asignación de desestructuración",
      "action": "Cambiar nombres con la asignación de desestructuración",
      "code": "const {names:newName , age:newAge } = user;",
      "example": "const { johnDoe: { age, email }} = user ''- const { johnDoe: { age:newAge, email:newEmail }} = user"
    },
    {
      "title": "desestructuración para asignar variables de objetos anidados.",
      "action": "asignación de desestructuración para asignar variables de objetos anidados. Lo que se está copiando es la propiedad y no el objeto en si.",
      "code": "const {yesterday:{low:newLow,high:newHigh}} = LOCAL_FORECAST;",
      "example": "const LOCAL_FORECAST = {  yesterday: { low: 61, high: 75 },  today: { low: 64, high: 77 },  tomorrow: { low: 68, high: 80 }}"
    },
    {
      "title": "desestructuración para asignar variables de matrices",
      "action": "asignación de desestructuración para asignar variables de matrices",
      "code": "const [a, b] = [1, 2, 3, 4, 5, 6]; const [a, b,,, c] = [1, 2, 3, 4, 5, 6]; ",
      "example": "data"
    },
    {
      "title": "desestructuración con el parámetro Rest ",
      "action": "asignación de desestructuración con el parámetro Rest para reasignar elementos de matriz. En algunas situaciones que involucran la desestructuración de matrices, es posible que deseemos recopilar el resto de los elementos en una matriz separada.",
      "code": "const [a, b, ...arr] = [1, 2, 3, 4, 5, 7]; console.log(a, b); console.log(arr);",
      "example": "La consola mostraría los valores 1, 2y [3, 4, 5, 7]."
    },
    {
      "title": "desestructuración para pasar un objeto como parámetros de una función",
      "action": "asignación de desestructuración para pasar un objeto como parámetros de una función. En algunos casos, puede desestructurar el objeto en un argumento de función.",
      "code": "const profileUpdate = (profileData) => {  const { name, age, nationality, location }= profileData;}",
      "example": "Esto efectivamente destruye el objeto enviado a la función. Esto también se puede hacer in situ: const profileUpdate = ({ name, age, nationality, location }) => {} Cuando profile Datase pasa a la función anterior, los valores se desestructuran del parámetro de función para su uso dentro de la función."
    },
    {
      "title": " cadenas con literales de plantilla",
      "action": "Crear cadenas con literales de plantilla. Una nueva característica de ES6 es la plantilla literal . Este es un tipo especial de cuerda que facilita la creación de cuerdas complejas. Los literales de plantilla le permiten crear cadenas de varias líneas y utilizar funciones de interpolación de cadenas para crear cadenas.",
      "code": "const person = {  name: 'Zodiac Hasbro',  age: 56};const greeting = `Hello, myname is ${person.name}!I am ${person.age} years old.`;console.log(greeting);",
      "example": "La consola mostrará las cadenas Hello, my name is Zodiac Hasbro!y I am 56 years old."
    },
    {
      "title": "Marcador de posición",
      "action": "Marcador de posición : ${variable}",
      "code": "${ y }  ${person.name}",
      "example": "La ${variable}sintaxis utilizada anteriormente es un marcador de posición. Básicamente, ya no tendrá que usar la concatenación con el +operador. Para agregar variables a cadenas, simplemente suelte la variable en una cadena de plantilla y envuélvala con ${ y }."
    },
    {
      "title": "cadenas literales",
      "action": "Aplicación de cadenas literales",
      "code": "for(var i= 0; i < arr.length; i++){ failureItems[i] = `<li class='text-warning' >${arr[i]}</li>`; }",
      "example": "salida:[  '<li class='text-warning'>no-var</li>',   '<li class='text-warning'>var-on-top</li>',  '<li class='text-warning'>linebreak</li>' ]"
    },
    {
      "title": "declaraciones concisas de literales de objetos",
      "action": "Escribir declaraciones concisas de literales de objetos utilizando la abreviatura de propiedades de objeto",
      "code": "const getMousePosition = (x, y) => ({   x: x,   y: y }); se puede traducir como: const getMousePosition = (x, y) => ({ x, y });",
      "example": "getMousePositiones una función simple que devuelve un objeto que contiene dos propiedades. ES6 proporciona el azúcar sintáctico para eliminar la redundancia de tener que escribir x: x. Simplemente puede escribir xuna vez y se convertirá en x: x(o algo equivalente) bajo el capó. "
    },
    {
      "title": "funciones declarativas concisas",
      "action": "Escribir funciones declarativas concisas con ES6",
      "code": "const person = {  name: 'Taylor',  sayHello() {  return `Hello! My name is ${this.name}.`;  }};",
      "example": "data"
    },
    {
      "title": "constructor ES5",
      "action": "Definir una función de constructor ES5",
      "code": "var SpaceShuttle = function(targetPlanet){ this.targetPlanet = targetPlanet;} var zeus = new SpaceShuttle('Jupiter'); ",
      "example": "En ES5, generalmente definimos una constructor función y usamos la newpalabra clave para crear una instancia de un objeto."
    },
    {
      "title": "crear objetos, utilizando la palabra clave class",
      "action": " ES6 proporciona una nueva sintaxis para crear objetos, utilizando la palabra clave class .",
      "code": "class SpaceShuttle { constructor(targetPlanet){ this.targetPlanet = targetPlanet; }} const zeus = new SpaceShuttle('Jupiter');",
      "example": "Cabe señalar que la classpalabra clave declara una nueva función, a la que se agrega un constructor. Este constructor se invoca cuando newse llama para crear un nuevo objeto. Nota: UpperCamelCase debe usarse por convención para los nombres de clase de ES6, como se SpaceShuttleusó anteriormente."
    },
    {
      "title": "getters y setters",
      "action": "Utilice captadores y definidores para controlar el acceso a un objeto. Las funciones de obtención están destinadas a simplemente devolver (obtener) el valor de la variable privada de un objeto al usuario sin que el usuario acceda directamente a la variable privada. Las funciones de establecimiento están destinadas a modificar (establecer) el valor de la variable privada de un objeto en función del valor pasado a la función de establecimiento. Este cambio podría implicar cálculos o incluso sobrescribir completamente el valor anterior. ",
      "code": "class Book {  constructor(author) {    this._author = author;  }  '- getter  get writer(){    return this._author;  }  '- setter  set writer(updatedAuthor) { this._author = updatedAuthor;  }}",
      "example": "const novel = new Book('anonymous') console.log(novel.writer) novel.writer = 'newAuthor' console.log(novel.writer)//La consola mostraría las cadenas anonymousy newAuthor. Observe la sintaxis utilizada para invocar al getter y al setter."
    },
    {
      "title": "Crear un script de módulo",
      "action": "JavaScript comenzó con un pequeño papel que desempeñar en una web que de otro modo sería principalmente HTML. Hoy en día, es enorme y algunos sitios web están construidos casi en su totalidad con JavaScript. Para hacer que JavaScript sea más modular, limpio y fácil de mantener; ES6 introdujo una forma de compartir fácilmente código entre archivos JavaScript. Esto implica exportar partes de un archivo para usar en uno o más archivos e importar las partes que necesita, donde las necesita. Para aprovechar esta funcionalidad, debe crear un script en su documento HTML con una extensión typede module. ",
      "code": "<script type='module' src='filename.js'></script>",
      "example": "Un script que usa este moduletipo ahora puede usar las funciones importy exportque aprenderá en los próximos desafíos."
    },
    {
      "title": "exportación para compartir un bloque de código",
      "action": "magine un archivo llamado math_functions.jsque contiene varias funciones relacionadas con operaciones matemáticas. Uno de ellos se almacena en una variable add, que toma dos números y devuelve su suma. Desea utilizar esta función en varios archivos JavaScript diferentes. Para compartirlo con estos otros archivos, primero debe exporthacerlo.",
      "code": "export const add = (x, y) => { return x + y;}",
      "example": "Lo anterior es una forma común de exportar una sola función, pero puede lograr lo mismo como esto: const add = (x, y) => {  return x + y} export { add } Cuando exporta una variable o función, puede importarla en otro archivo y usarla sin tener que volver a escribir el código. Puede exportar varias cosas repitiendo el primer ejemplo para cada cosa que desee exportar, o colocándolas todas en la declaración de exportación del segundo ejemplo, así: export { add, subtract }"
    },
    {
      "title": "Reutilizar código JavaScript mediante la importación",
      "action": "importle permite elegir qué partes de un archivo o módulo cargar. En la lección anterior, los ejemplos exportados adddel math_functions.jsarchivo. A continuación, le mostramos cómo puede importarlo para usarlo en otro archivo:",
      "code": "import { add } from './math_functions.js';",
      "example": "Aquí, importencontrará adden math_functions.js, importará solo esa función para su uso e ignorará el resto. El ./le dice a la importación que busque el math_functions.jsarchivo en la misma carpeta que el archivo actual. La ruta de archivo relativa ( ./) y la extensión de archivo ( .js) son necesarias cuando se utiliza la importación de esta manera. Puede importar más de un elemento del archivo agregándolos en la importdeclaración como esta: import { add, subtract } from './math_functions.js'"
    },
    {
      "title": "Utilice * para importar todo desde un archivo",
      "action": "Suponga que tiene un archivo y desea importar todo su contenido al archivo actual. Esto se puede hacer con la import * assintaxis. A continuación, se muestra un ejemplo en el que el contenido de un archivo con nombre math_functions.jsse importa a un archivo en el mismo directorio:",
      "code": "import * as myMathModule from './math_functions.js';",
      "example": "La importdeclaración anterior creará un objeto llamado myMathModule. Este es solo un nombre de variable, puedes nombrarlo como quieras. El objeto contendrá todas las exportaciones desde math_functions.jsél, por lo que puede acceder a las funciones como lo haría con cualquier otra propiedad de objeto. A continuación, le indicamos cómo puede utilizar las funciones addy subtractque se importaron: myMathModule.add(2,3); myMathModule.subtract(5,3)"
    },
    {
      "title": "Crear un respaldo de exportación con exportación predeterminada",
      "action": "En la exportlección, aprendió sobre la sintaxis a la que se hace referencia como exportación con nombre . Esto le permitió hacer que múltiples funciones y variables estuvieran disponibles para su uso en otros archivos. Hay otra exportsintaxis que necesita conocer, conocida como exportación predeterminada . Por lo general, utilizará esta sintaxis si solo se exporta un valor de un archivo. También se utiliza para crear un valor de reserva para un archivo o módulo. A continuación se muestran ejemplos que utilizan export default:",
      "code": "export default function add(x, y) {  return x + y;} export default function(x, y) { return x + y;}",
      "example": "data"
    },
    {
      "title": "Importar una exportación predeterminada",
      "action": "En el último desafío, aprendiste sobre export defaultsus usos. Para importar una exportación predeterminada, debe utilizar una importsintaxis diferente . En el siguiente ejemplo, addes la exportación predeterminada del math_functions.jsarchivo. A continuación se explica cómo importarlo:",
      "code": "import add from './math_functions.js';",
      "example": "La sintaxis difiere en un lugar clave. El valor importado, addno está rodeado por llaves ( {}). addaquí es simplemente un nombre de variable para cualquiera que sea la exportación predeterminada del math_functions.jsarchivo. Puede utilizar cualquier nombre aquí al importar un archivo."
    },
    {
      "title": "Crear una promesa de JavaScript",
      "action": "Una promesa en JavaScript es exactamente lo que parece: la usas para hacer una promesa de hacer algo, generalmente de forma asincrónica. Cuando la tarea se completa, cumple con su promesa o no lo hace. Promisees una función de constructor, por lo que debe usar la newpalabra clave para crear una. Toma una función, como argumento, con dos parámetros: resolvey reject. Estos son métodos que se utilizan para determinar el resultado de la promesa. La sintaxis se ve así:",
      "code": "const myPromise = new Promise((resolve, reject) => {});",
      "example": "data"
    },
    {
      "title": "Complete a Promise with resolve and reject",
      "action": "na promesa tiene tres estados: pending, fulfilled, y rejected. La promesa que creaste en el último desafío está estancada para siempre en el pendingestado porque no agregaste una forma de completar la promesa. Los parámetros resolvey rejectdados al argumento de promesa se utilizan para hacer esto. resolvese usa cuando desea que su promesa tenga éxito y rejectse usa cuando desea que fracase. Estos son métodos que toman un argumento, como se ve a continuación.",
      "code": "const myPromise = new Promise((resolve, reject) => {  if(condition here) {    resolve('Promise was fulfilled');  } else {    reject('Promise was rejected');  }});",
      "example": "El ejemplo anterior usa cadenas para el argumento de estas funciones, pero realmente puede ser cualquier cosa. A menudo, podría ser un objeto del que usaría datos para colocar en su sitio web o en otro lugar."
    },
    {
      "title": "Maneje una promesa cumplida con then",
      "action": "Las promesas son más útiles cuando tiene un proceso que toma una cantidad de tiempo desconocida en su código (es decir, algo asincrónico), a menudo una solicitud del servidor. Cuando realiza una solicitud de servidor, lleva algo de tiempo y, una vez que se completa, Generalmente desea hacer algo con la respuesta del servidor. Esto se puede lograr utilizando el thenmétodo. El thenmétodo se ejecuta inmediatamente después de que se cumpla su promesa con resolve. He aquí un ejemplo:",
      "code": "myPromise.then(result => {});",
      "example": "result proviene del argumento dado al método resolve."
    },
    {
      "title": "Maneje una promesa rechazada con catch",
      "action": "catches el método utilizado cuando su promesa ha sido rechazada. Se ejecuta inmediatamente después de rejectllamar al método de una promesa . Esta es la sintaxis:",
      "code": "myPromise.catch(error => {});",
      "example": "errores el argumento que se pasa al rejectmétodo."
    },
    {
      "title": "método de prueba",
      "action": "Las expresiones regulares se utilizan en lenguajes de programación para hacer coincidir partes de cadenas. Creas patrones para ayudarte a hacer esa combinación. Si usted quiere encontrar la palabra theen la cadena The dog chased the cat, se puede usar la siguiente expresión regular: /the/. Tenga en cuenta que las comillas no son necesarias dentro de la expresión regular. JavaScript tiene varias formas de usar expresiones regulares. Una forma de probar una expresión regular es usar el .test()método. El .test()método toma la expresión regular, la aplica a una cadena (que se coloca entre paréntesis) y devuelve trueo falsesi su patrón encuentra algo o no.",
      "code": "let testStr = 'freeCodeCamp'; let testRegex = /Code/; testRegex.test(testStr);",
      "example": "El testmétodo aquí regresa true."
    },
    {
      "title": "coincidir una cadena literal con diferentes posibilidades",
      "action": "Puede buscar varios patrones de uso de la alternationo ORdel operador: Este operador hace coincidir patrones antes o después de él. Por ejemplo, si desea hacer coincidir las cadenas yeso no, la expresión regular que desea es /yes|no/. También puede buscar más de dos patrones. Puede hacer esto agregando más patrones con más ORoperadores separándolos, como /yes|no|maybe/.",
      "code": "let petString = 'James has a pet cat.'; let petRegex = /dog|cat|bird|fish/;",
      "example": "let result = petRegex.test(petString);"
    },
    {
      "title": "Ignorar mayúsculas y minúsculas durante la coincidencia",
      "action": "El caso (o a veces el caso de la letra) es la diferencia entre letras mayúsculas y minúsculas. Ejemplos de mayúsculas son A, B, y C. Ejemplos de minúsculas son a, b, y c. Puede hacer coincidir ambos casos usando lo que se llama una bandera. Hay otras banderas, pero aquí se enfocará en la bandera que ignora las mayúsculas y minúsculas: la ibandera. Puede usarlo agregándolo a la expresión regular. ",
      "code": "Un ejemplo del uso de esta bandera es /ignorecase/i.",
      "example": "Esta expresión regular puede igualar las cuerdas ignorecase, igNoreCasey IgnoreCase."
    },
    {
      "title": "Extraer coincidencias",
      "action": "Hasta ahora, solo ha estado verificando si existe un patrón o no dentro de una cadena. También puede extraer las coincidencias reales que encontró con el .match()método. Para usar el método .match(), aplique el método en una cadena y pase la expresión regular entre paréntesis.",
      "code": "Hello, World!'.match(/Hello/); let ourStr = 'Regular expressions'; let ourRegex = /expressions/; ourStr.match(ourRegex);",
      "example": "Aquí match volvería el primero ['Hello']y volvería el segundo ['expressions']. Tenga en cuenta que la .matchsintaxis es 'opuesta' al .testmétodo que ha estado utilizando hasta ahora: 'string'.match(/regex/); /regex/.test('string');"
    },
    {
      "title": "Encontrar más de una coincidencia",
      "action": "Para encontrar más de unha coincidenciase debe utilizar labvandera g",
      "code": "let testStr = 'Repeat, Repeat, Repeat'; let repeatRegex = /Repeat/g; testStr.match(repeatRegex);",
      "example": "Y aqui match devuelve el valor['Repeat', 'Repeat', 'Repeat']. Nota: Puede tener varias banderas en su expresión regular como/search/gi"
    },
    {
      "title": "Carácter comodín",
      "action": "A veces no (o no es necesario) conocer los caracteres exactos en sus patrones. Pensando en todas las palabras que coinciden, digamos, una falta de ortografía llevaría mucho tiempo. Afortunadamente, puede ahorrar tiempo utilizando el carácter comodín:.  l carácter comodín .coincidirá con cualquier carácter. El comodín también se llama doty period. Puede utilizar el carácter comodín como cualquier otro carácter en la expresión regular. Por ejemplo, si desea hacer coincidir hug, huh, hut, y hum, se puede utilizar la expresión regular /hu./para que coincida con las cuatro palabras.",
      "code": "let humStr = 'I'll hum a song'; let hugStr = 'Bear hug'; let huRegex = /hu./; huRegex.test(humStr); huRegex.test(hugStr);",
      "example": "Ambas testllamadas regresarían true."
    },
    {
      "title": "Combina un solo caracter con múltiples posibilidades",
      "action": "Aprendió a hacer coincidir patrones literales ( /literal/) y caracteres comodín ( /./). Esos son los extremos de las expresiones regulares, donde uno encuentra coincidencias exactas y el otro coincide con todo. Hay opciones que son un equilibrio entre los dos extremos.Puede buscar un patrón literal con cierta flexibilidad con las clases de caracteres . Las clases de caracteres le permiten definir un grupo de caracteres que desea hacer coincidir colocándolos entre corchetes ( [y ]). Por ejemplo, desea hacer coincidir bag, bigy bugpero no bog. Puede crear la expresión regular /b[aiu]g/para hacer esto. El [aiu]es la clase de caracteres que sólo coincidirá con los personajes a, i, o u.",
      "code": "let bigStr = 'big'; let bagStr = 'bag'; let bugStr = 'bug'; let bogStr = 'bog'; let bgRegex = /b[aiu]g/; bigStr.match(bgRegex); bagStr.match(bgRegex); bugStr.match(bgRegex); bogStr.match(bgRegex); ",
      "example": "En orden, los cuatro match llamadas volverían los valores ['big'], ['bag'], ['bug'], y null."
    },
    {
      "title": "Coincidir con un rango de caracteres",
      "action": "Dentro de un conjunto de caracteres, se puede definir un rango de caracteres para que coincida con el uso de un carácter de guión: -.  Por ejemplo, para que coincida con las letras minúsculas aa través eusaría [a-e].",
      "code": "let catStr = 'cat'; let batStr = 'bat'; let matStr = 'mat'; let bgRegex = /[a-e]at/; catStr.match(bgRegex); batStr.match(bgRegex); matStr.match(bgRegex); ",
      "example": "En orden, las tres match llamadas volverían los valores ['cat'], ['bat']y null."
    },
    {
      "title": "Coincidir números y letras del alfabeto",
      "action": "El uso del guión ( -) para hacer coincidir un rango de caracteres no se limita a letras. También funciona para hacer coincidir un rango de números. Por ejemplo, /[0-5]/coincide con cualquier número entre 0y 5, incluido 0y 5. Además, es posible combinar un rango de letras y números en un solo juego de caracteres. ",
      "code": "let jennyStr = 'Jenny8675309'; let myRegex = /[a-z0-9]/ig; jennyStr.match(myRegex); ",
      "example": "jennyStr.match(myRegex); "
    },
    {
      "title": "Coincidir con caracteres individuales no especificados",
      "action": "Hasta ahora, ha creado un conjunto de caracteres que desea hacer coincidir, pero también puede crear un conjunto de caracteres que no desea hacer coincidir. Estos tipos de juegos de caracteres se denominan juegos de caracteres negados. Para crear un conjunto de caracteres negado, coloque un carácter de intercalación ( ^) después del corchete de apertura y antes de los caracteres que no desea hacer coincidir.",
      "code": "Por ejemplo, /[^aeiou]/gi coincide con todos los caracteres que no son vocales. Tenga en cuenta que caracteres  como ., !, [, @, /y el espacio en blanco se emparejan.",
      "example": "Sólo el conjunto de caracteres negada vocal excluye los caracteres vocales."
    },
    {
      "title": "Coincidir con los personajes que aparecen una o más veces",
      "action": "A veces, es necesario hacer coincidir un caracter (o grupo de caracteres que aparece una o más veces seguidas. Esto significa que ocurre al menos una vez y puede repetirse. Puede utilizar el +carácter para comprobar si ese es el caso. Recuerde, el personaje o patrón debe estar presente de forma consecutiva. Es decir, el personaje tiene que repetir uno tras otro.",
      "code": "Por ejemplo, /a+/gencontraría una coincidencia abcy regresaría ['a']. Debido a +eso, también encontraría una única coincidencia aabcy regresaría ['aa'].",
      "example": "Si, en cambio, estuviera verificando la cadena abab, encontraría dos coincidencias y regresaría ['a', 'a']porque los acaracteres no están en una fila, hay un bentre ellos. Finalmente, dado que no hay un no aen la cadena bcd, no encontraría una coincidencia."
    },
    {
      "title": "Coincidir con personajes que aparecen cero o más veces",
      "action": "El último desafío utilizó el +signo más para buscar caracteres que aparecen una o más veces. También hay una opción que coincide con los caracteres que aparecen cero o más veces. El carácter de hacerlo es el asterisco o estrella: *.",
      "code": "let soccerWord = 'gooooooooal!'; let gPhrase = 'gut feeling'; let oPhrase = 'over the moon'; let goRegex = /go*/; ",
      "example": "soccerWord.match(goRegex); gPhrase.match(goRegex); oPhrase.match(goRegex);"
    },
    {
      "title": "Encuentra caracteres con lazy math",
      "action": "En las expresiones regulares, una coincidencia codiciosa encuentra la parte más larga posible de una cadena que se ajusta al patrón de expresiones regulares y la devuelve como una coincidencia. La alternativa se llama coincidencia diferida , que encuentra la parte más pequeña posible de la cadena que satisface el patrón de expresiones regulares.",
      "code": "expresión regular /t[a-z]*i/a la cadena 'titanic'. Esta expresión regular es básicamente un patrón que comienza con t, termina con iy tiene algunas letras en el medio. Las expresiones regulares son codiciosas por defecto, por lo que la coincidencia volvería ['titani']. Encuentra la subcadena más grande posible para ajustarse al patrón.",
      "example": "Sin embargo, puedes usar el ?personaje para cambiarlo a una coincidencia perezosa. 'titanic'comparado con la expresión regular ajustada de las /t[a-z]*?i/devoluciones ['ti']. Nota: Se debe evitar analizar HTML con expresiones regulares, pero el patrón que coincide con una cadena HTML con expresiones regulares está completamente bien."
    }
  ]
}
